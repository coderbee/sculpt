{
  
    
        "post0": {
            "title": "Scala Cookbook",
            "content": "Introduction . Basics . No semi-colons necessary | Type inference | FUnctional programming + Objected oriented nature | . Scala expressions . 1 + 1 . res7: Int = 2 . Var versus Val . Variables declared using (Var) are mutable variables Values declared using (Val) are immutable constants . From a functional programming perspective it is advisable to use val whereever possible, to prevent unnecessary/mistaken changes to data. . var counter = 1 . counter: Int = 2 . counter = 2 . val pi = 3.14 . pi: Double = 3.14 . pi = 3.1416 . cmd11.sc:1: reassignment to val val res11 = pi = 3.1416 ^Compilation Failed . Compilation Failed . Motivation . Now that you are familiar with Scala, let&#39;s start carving out some hardware! Chisel stands for Constructing Hardware In a Scala Embedded Language. That means it is a DSL in Scala, allowing you to take advantage of both Scala and Chisel programming within the same code. It is important to understand which code is &quot;Scala&quot; and which code is &quot;Chisel&quot;, but we will discuss that more later. For now, think of Chisel and the code in Module 2 as a better way to write Verilog. This module throws an entire Chisel Module and tester at you. Just get the gist of it for now. You&#39;ll see plenty more examples later. . Setup . The following cell downloads the dependencies needed for Chisel. You will see it in all future notebooks. Run this cell now. . val path = System.getProperty(&quot;user.dir&quot;) + &quot;/source/load-ivy.sc&quot; interp.load.module(ammonite.ops.Path(java.nio.file.FileSystems.getDefault().getPath(path))) . As mentioned in the last module, these statements are needed to import Chisel. Run this cell now before running any future code blocks. . import chisel3._ import chisel3.util._ import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester} . . Your First Module . This section will present your first hardware module, a test case, and how to run it. It will contain many things that you will not understand, and that is OK. We want you to take away the broad strokes, so you can continually return to this complete and working example to reinforce what you&#39;ve learned. . **Example: A Module** Like Verilog, we can declare module definitions in Chisel. The following example is a Chisel Module, Passthrough, that has one 4-bit input, in, and one 4-bit output, out. The module combinationally connects in and out, so in drives out. . // Chisel Code: Declare a new module definition class Passthrough extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in } . There&#39;s a lot here! The following explains how to think of each line in terms of the hardware we are describing. . class Passthrough extends Module { . We declare a new module called Passthrough. Module is a built-in Chisel class that all hardware modules must extend. . val io = IO(...) . We declare all our input and output ports in a special io val. It must be called io and be an IO object or instance, which requires something of the form IO(_instantiated_bundle_). . new Bundle { val in = Input(...) val out = Output(...) } . We declare a new hardware struct type (Bundle) that contains some named signals in and out with directions Input and Output, respectively. . UInt(4.W) . We declare a signal&#39;s hardware type. In this case, it is an unsigned integer of width 4. . io.out := io.in . We connect our input port to our output port, such that io.in drives io.out. Note that the := operator is a Chisel operator that indicates that the right-hand signal drives the left-hand signal. It is a directioned operator. . The neat thing about hardware construction languages (HCLs) is that we can use the underlying programming language as a scripting language. For example, after declaring our Chisel module, we then use Scala to call the Chisel compiler to translate Chisel Passthrough into Verilog Passthrough. This process is called elaboration. . // Scala Code: Elaborate our Chisel design by translating it to Verilog // Don&#39;t worry about understanding this code; it is very complicated Scala println(getVerilog(new Passthrough)) . Note that the Name of our module is cmd&lt;#&gt;WrapperHelperPassthrough, which is an artifact of running this tutorial in Jupyter. In your normal code, its name should just be Passthrough. This is an important lesson though - although Chisel does its best to preserve the names of your modules and other hardware components, sometimes it fails to do so. . **Example: A Module Generator** If we apply what we learned about Scala to this example, we can see that a Chisel module is implemented as a Scala class. Just like any other Scala class, we could make a Chisel module take some construction parameters. In this case, we make a new class PassthroughGenerator which will accept an integer width that dictates the widths of its input and output ports: . // Chisel Code, but pass in a parameter to set widths of ports class PassthroughGenerator(width: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(width.W)) val out = Output(UInt(width.W)) }) io.out := io.in } // Let&#39;s now generate modules with different widths println(getVerilog(new PassthroughGenerator(10))) println(getVerilog(new PassthroughGenerator(20))) . Notice that the generated Verilog uses different bitwidths for the input/output depending on the value assigned to the width parameter. Let&#39;s dig into how this works. Because Chisel Modules are normal Scala classes, we can use the power of Scala&#39;s class constructors to parameterize the elaboration of our design. . You may notice that this parameterization is enabled by Scala, not Chisel; Chisel has no extra APIs for parameterization, but a designer can simply leverage Scala features to parameterize his/her designs. . Because PassthroughGenerator no longer describes a single Module, but instead describes a family of modules parameterized by width, we refer to this Passthrough as a generator. . . Testing Your Hardware . No hardware module or generator should be complete without a tester. Chisel has built-in test features that you will explore throughout this bootcamp. The following example is a Chisel test harness that passes values to an instance of Passthrough&#39;s input port in, and checks that the same value is seen on the output port out. . **Example: A Tester** There is some advanced Scala going on here. However, there is no need for you to understand anything except the poke and expect commands. You can think of the rest of the code as simply boilerplate to write these simple tests. . // Scala Code: Calling Driver to instantiate Passthrough + PeekPokeTester and execute the test. // Don&#39;t worry about understanding this code; it is very complicated Scala. // Think of it more as boilerplate to run a Chisel test. val testResult = Driver(() =&gt; new Passthrough()) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) // Set our input to value 0 expect(c.io.out, 0) // Assert that the output correctly has 0 poke(c.io.in, 1) // Set our input to value 1 expect(c.io.out, 1) // Assert that the output correctly has 1 poke(c.io.in, 2) // Set our input to value 2 expect(c.io.out, 2) // Assert that the output correctly has 2 } } assert(testResult) // Scala Code: if testResult == false, will throw an error println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . What&#39;s going on? The test accepts a Passthrough module, assigns values to the module&#39;s inputs, and checks its outputs. To set an input, we call poke. To check an output, we call expect. If we don&#39;t want to compare the output to an expected value (no assertion), we can peek the output instead. . If all expect statements are true, then our boilerplate code will return true (see testResult). . **Exercise: Writing Your Own Testers** Write and execute two tests, one that tests PassthroughGenerator for a width of 10 and a second that tests PassthroughGenerator for a width of 20. Check at least two values for each: zero and the maximum value supported by the specified width. Note that the triple question mark has a special meaning in Scala. You may see it frequently in these bootcamp exercises. Running code with the ??? will produce the NotImplementedError. Replace ??? with your testers. . val test10result = ??? val test20result = ??? assert((test10result == true) &amp;&amp; (test20result == true)) println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . Solution (click to toggle displaying it) val test10result = Driver(() =&gt; new PassthroughGenerator(10)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1023) expect(c.io.out, 1023) } } val test20result = Driver(() =&gt; new PassthroughGenerator(20)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1048575) expect(c.io.out, 1048575) } } . . Looking at Generated Verilog/FIRRTL . If you are having trouble understanding the generated hardware and are comfortable with reading structural Verilog and/or FIRRTL (Chisel&#39;s IR which is comparable to a synthesis-only subset of Verilog), then you can try looking at the generated Verilog to see the result of Chisel execution. . Here is an example of generating the Verilog (which you&#39;ve seen already) and the FIRRTL. . // Viewing the Verilog for debugging println(getVerilog(new Passthrough)) . // Viewing the firrtl for debugging println(getFirrtl(new Passthrough)) . . You&#39;re done! . Return to the top. . Appendix: A Note on &quot;printf&quot; Debugging . Debugging with print statements is not always the best way to debug, but is often an easy first step to see what&#39;s going on when something doesn&#39;t work the way you expect. Because Chisel generators are programs generating hardware, there are some extra subtleties about printing generator and circuit state. It is important to remember when your print statement executes and what is being printed. The three common scenarios where you might want to print have some important differences: . Chisel generator prints during circuit generation | Circuit prints during circuit simulation | Tester prints during testing | . println is a built-in Scala function that prints to the console. It cannot be used to print during circuit simulation because the generated circuit is FIRRTL or Verilog- not Scala. . The following code block shows different styles of printing. . class PrintingModule extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in printf(&quot;Print during simulation: Input is %d n&quot;, io.in) // chisel printf has its own string interpolator too printf(p&quot;Print during simulation: IO is $io n&quot;) println(s&quot;Print during generation: Input is ${io.in}&quot;) } class PrintingModuleTester(c: PrintingModule) extends PeekPokeTester(c) { poke(c.io.in, 3) step(5) // circuit will print println(s&quot;Print during testing: Input is ${peek(c.io.in)}&quot;) } chisel3.iotesters.Driver( () =&gt; new PrintingModule ) { c =&gt; new PrintingModuleTester(c) } .",
            "url": "https://coderbee.github.io/sculpt/2020/07/07/scala-cookbook.html",
            "relUrl": "/2020/07/07/scala-cookbook.html",
            "date": " • Jul 7, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "FIRRTL Cookbook",
            "content": "Introduction . . Motivation . Now that you are familiar with Scala, let&#39;s start carving out some hardware! Chisel stands for Constructing Hardware In a Scala Embedded Language. That means it is a DSL in Scala, allowing you to take advantage of both Scala and Chisel programming within the same code. It is important to understand which code is &quot;Scala&quot; and which code is &quot;Chisel&quot;, but we will discuss that more later. For now, think of Chisel and the code in Module 2 as a better way to write Verilog. This module throws an entire Chisel Module and tester at you. Just get the gist of it for now. You&#39;ll see plenty more examples later. . Setup . The following cell downloads the dependencies needed for Chisel. You will see it in all future notebooks. Run this cell now. . val path = System.getProperty(&quot;user.dir&quot;) + &quot;/source/load-ivy.sc&quot; interp.load.module(ammonite.ops.Path(java.nio.file.FileSystems.getDefault().getPath(path))) . As mentioned in the last module, these statements are needed to import Chisel. Run this cell now before running any future code blocks. . import chisel3._ import chisel3.util._ import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester} . . Your First Module . This section will present your first hardware module, a test case, and how to run it. It will contain many things that you will not understand, and that is OK. We want you to take away the broad strokes, so you can continually return to this complete and working example to reinforce what you&#39;ve learned. . **Example: A Module** Like Verilog, we can declare module definitions in Chisel. The following example is a Chisel Module, Passthrough, that has one 4-bit input, in, and one 4-bit output, out. The module combinationally connects in and out, so in drives out. . // Chisel Code: Declare a new module definition class Passthrough extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in } . There&#39;s a lot here! The following explains how to think of each line in terms of the hardware we are describing. . class Passthrough extends Module { . We declare a new module called Passthrough. Module is a built-in Chisel class that all hardware modules must extend. . val io = IO(...) . We declare all our input and output ports in a special io val. It must be called io and be an IO object or instance, which requires something of the form IO(_instantiated_bundle_). . new Bundle { val in = Input(...) val out = Output(...) } . We declare a new hardware struct type (Bundle) that contains some named signals in and out with directions Input and Output, respectively. . UInt(4.W) . We declare a signal&#39;s hardware type. In this case, it is an unsigned integer of width 4. . io.out := io.in . We connect our input port to our output port, such that io.in drives io.out. Note that the := operator is a Chisel operator that indicates that the right-hand signal drives the left-hand signal. It is a directioned operator. . The neat thing about hardware construction languages (HCLs) is that we can use the underlying programming language as a scripting language. For example, after declaring our Chisel module, we then use Scala to call the Chisel compiler to translate Chisel Passthrough into Verilog Passthrough. This process is called elaboration. . // Scala Code: Elaborate our Chisel design by translating it to Verilog // Don&#39;t worry about understanding this code; it is very complicated Scala println(getVerilog(new Passthrough)) . Note that the Name of our module is cmd&lt;#&gt;WrapperHelperPassthrough, which is an artifact of running this tutorial in Jupyter. In your normal code, its name should just be Passthrough. This is an important lesson though - although Chisel does its best to preserve the names of your modules and other hardware components, sometimes it fails to do so. . **Example: A Module Generator** If we apply what we learned about Scala to this example, we can see that a Chisel module is implemented as a Scala class. Just like any other Scala class, we could make a Chisel module take some construction parameters. In this case, we make a new class PassthroughGenerator which will accept an integer width that dictates the widths of its input and output ports: . // Chisel Code, but pass in a parameter to set widths of ports class PassthroughGenerator(width: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(width.W)) val out = Output(UInt(width.W)) }) io.out := io.in } // Let&#39;s now generate modules with different widths println(getVerilog(new PassthroughGenerator(10))) println(getVerilog(new PassthroughGenerator(20))) . Notice that the generated Verilog uses different bitwidths for the input/output depending on the value assigned to the width parameter. Let&#39;s dig into how this works. Because Chisel Modules are normal Scala classes, we can use the power of Scala&#39;s class constructors to parameterize the elaboration of our design. . You may notice that this parameterization is enabled by Scala, not Chisel; Chisel has no extra APIs for parameterization, but a designer can simply leverage Scala features to parameterize his/her designs. . Because PassthroughGenerator no longer describes a single Module, but instead describes a family of modules parameterized by width, we refer to this Passthrough as a generator. . . Testing Your Hardware . No hardware module or generator should be complete without a tester. Chisel has built-in test features that you will explore throughout this bootcamp. The following example is a Chisel test harness that passes values to an instance of Passthrough&#39;s input port in, and checks that the same value is seen on the output port out. . **Example: A Tester** There is some advanced Scala going on here. However, there is no need for you to understand anything except the poke and expect commands. You can think of the rest of the code as simply boilerplate to write these simple tests. . // Scala Code: Calling Driver to instantiate Passthrough + PeekPokeTester and execute the test. // Don&#39;t worry about understanding this code; it is very complicated Scala. // Think of it more as boilerplate to run a Chisel test. val testResult = Driver(() =&gt; new Passthrough()) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) // Set our input to value 0 expect(c.io.out, 0) // Assert that the output correctly has 0 poke(c.io.in, 1) // Set our input to value 1 expect(c.io.out, 1) // Assert that the output correctly has 1 poke(c.io.in, 2) // Set our input to value 2 expect(c.io.out, 2) // Assert that the output correctly has 2 } } assert(testResult) // Scala Code: if testResult == false, will throw an error println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . What&#39;s going on? The test accepts a Passthrough module, assigns values to the module&#39;s inputs, and checks its outputs. To set an input, we call poke. To check an output, we call expect. If we don&#39;t want to compare the output to an expected value (no assertion), we can peek the output instead. . If all expect statements are true, then our boilerplate code will return true (see testResult). . **Exercise: Writing Your Own Testers** Write and execute two tests, one that tests PassthroughGenerator for a width of 10 and a second that tests PassthroughGenerator for a width of 20. Check at least two values for each: zero and the maximum value supported by the specified width. Note that the triple question mark has a special meaning in Scala. You may see it frequently in these bootcamp exercises. Running code with the ??? will produce the NotImplementedError. Replace ??? with your testers. . val test10result = ??? val test20result = ??? assert((test10result == true) &amp;&amp; (test20result == true)) println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . Solution (click to toggle displaying it) val test10result = Driver(() =&gt; new PassthroughGenerator(10)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1023) expect(c.io.out, 1023) } } val test20result = Driver(() =&gt; new PassthroughGenerator(20)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1048575) expect(c.io.out, 1048575) } } . . Looking at Generated Verilog/FIRRTL . If you are having trouble understanding the generated hardware and are comfortable with reading structural Verilog and/or FIRRTL (Chisel&#39;s IR which is comparable to a synthesis-only subset of Verilog), then you can try looking at the generated Verilog to see the result of Chisel execution. . Here is an example of generating the Verilog (which you&#39;ve seen already) and the FIRRTL. . // Viewing the Verilog for debugging println(getVerilog(new Passthrough)) . // Viewing the firrtl for debugging println(getFirrtl(new Passthrough)) . . You&#39;re done! . Return to the top. . Appendix: A Note on &quot;printf&quot; Debugging . Debugging with print statements is not always the best way to debug, but is often an easy first step to see what&#39;s going on when something doesn&#39;t work the way you expect. Because Chisel generators are programs generating hardware, there are some extra subtleties about printing generator and circuit state. It is important to remember when your print statement executes and what is being printed. The three common scenarios where you might want to print have some important differences: . Chisel generator prints during circuit generation | Circuit prints during circuit simulation | Tester prints during testing | . println is a built-in Scala function that prints to the console. It cannot be used to print during circuit simulation because the generated circuit is FIRRTL or Verilog- not Scala. . The following code block shows different styles of printing. . class PrintingModule extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in printf(&quot;Print during simulation: Input is %d n&quot;, io.in) // chisel printf has its own string interpolator too printf(p&quot;Print during simulation: IO is $io n&quot;) println(s&quot;Print during generation: Input is ${io.in}&quot;) } class PrintingModuleTester(c: PrintingModule) extends PeekPokeTester(c) { poke(c.io.in, 3) step(5) // circuit will print println(s&quot;Print during testing: Input is ${peek(c.io.in)}&quot;) } chisel3.iotesters.Driver( () =&gt; new PrintingModule ) { c =&gt; new PrintingModuleTester(c) } .",
            "url": "https://coderbee.github.io/sculpt/2020/07/07/firrtl-cookbook.html",
            "relUrl": "/2020/07/07/firrtl-cookbook.html",
            "date": " • Jul 7, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Chisel Cookbook",
            "content": "Introduction . . Motivation . Now that you are familiar with Scala, let&#39;s start carving out some hardware! Chisel stands for Constructing Hardware In a Scala Embedded Language. That means it is a DSL in Scala, allowing you to take advantage of both Scala and Chisel programming within the same code. It is important to understand which code is &quot;Scala&quot; and which code is &quot;Chisel&quot;, but we will discuss that more later. For now, think of Chisel and the code in Module 2 as a better way to write Verilog. This module throws an entire Chisel Module and tester at you. Just get the gist of it for now. You&#39;ll see plenty more examples later. . Setup . The following cell downloads the dependencies needed for Chisel. You will see it in all future notebooks. Run this cell now. . val path = System.getProperty(&quot;user.dir&quot;) + &quot;/source/load-ivy.sc&quot; interp.load.module(ammonite.ops.Path(java.nio.file.FileSystems.getDefault().getPath(path))) . As mentioned in the last module, these statements are needed to import Chisel. Run this cell now before running any future code blocks. . import chisel3._ import chisel3.util._ import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester} . . Your First Module . This section will present your first hardware module, a test case, and how to run it. It will contain many things that you will not understand, and that is OK. We want you to take away the broad strokes, so you can continually return to this complete and working example to reinforce what you&#39;ve learned. . **Example: A Module** Like Verilog, we can declare module definitions in Chisel. The following example is a Chisel Module, Passthrough, that has one 4-bit input, in, and one 4-bit output, out. The module combinationally connects in and out, so in drives out. . // Chisel Code: Declare a new module definition class Passthrough extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in } . There&#39;s a lot here! The following explains how to think of each line in terms of the hardware we are describing. . class Passthrough extends Module { . We declare a new module called Passthrough. Module is a built-in Chisel class that all hardware modules must extend. . val io = IO(...) . We declare all our input and output ports in a special io val. It must be called io and be an IO object or instance, which requires something of the form IO(_instantiated_bundle_). . new Bundle { val in = Input(...) val out = Output(...) } . We declare a new hardware struct type (Bundle) that contains some named signals in and out with directions Input and Output, respectively. . UInt(4.W) . We declare a signal&#39;s hardware type. In this case, it is an unsigned integer of width 4. . io.out := io.in . We connect our input port to our output port, such that io.in drives io.out. Note that the := operator is a Chisel operator that indicates that the right-hand signal drives the left-hand signal. It is a directioned operator. . The neat thing about hardware construction languages (HCLs) is that we can use the underlying programming language as a scripting language. For example, after declaring our Chisel module, we then use Scala to call the Chisel compiler to translate Chisel Passthrough into Verilog Passthrough. This process is called elaboration. . // Scala Code: Elaborate our Chisel design by translating it to Verilog // Don&#39;t worry about understanding this code; it is very complicated Scala println(getVerilog(new Passthrough)) . Note that the Name of our module is cmd&lt;#&gt;WrapperHelperPassthrough, which is an artifact of running this tutorial in Jupyter. In your normal code, its name should just be Passthrough. This is an important lesson though - although Chisel does its best to preserve the names of your modules and other hardware components, sometimes it fails to do so. . **Example: A Module Generator** If we apply what we learned about Scala to this example, we can see that a Chisel module is implemented as a Scala class. Just like any other Scala class, we could make a Chisel module take some construction parameters. In this case, we make a new class PassthroughGenerator which will accept an integer width that dictates the widths of its input and output ports: . // Chisel Code, but pass in a parameter to set widths of ports class PassthroughGenerator(width: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(width.W)) val out = Output(UInt(width.W)) }) io.out := io.in } // Let&#39;s now generate modules with different widths println(getVerilog(new PassthroughGenerator(10))) println(getVerilog(new PassthroughGenerator(20))) . Notice that the generated Verilog uses different bitwidths for the input/output depending on the value assigned to the width parameter. Let&#39;s dig into how this works. Because Chisel Modules are normal Scala classes, we can use the power of Scala&#39;s class constructors to parameterize the elaboration of our design. . You may notice that this parameterization is enabled by Scala, not Chisel; Chisel has no extra APIs for parameterization, but a designer can simply leverage Scala features to parameterize his/her designs. . Because PassthroughGenerator no longer describes a single Module, but instead describes a family of modules parameterized by width, we refer to this Passthrough as a generator. . . Testing Your Hardware . No hardware module or generator should be complete without a tester. Chisel has built-in test features that you will explore throughout this bootcamp. The following example is a Chisel test harness that passes values to an instance of Passthrough&#39;s input port in, and checks that the same value is seen on the output port out. . **Example: A Tester** There is some advanced Scala going on here. However, there is no need for you to understand anything except the poke and expect commands. You can think of the rest of the code as simply boilerplate to write these simple tests. . // Scala Code: Calling Driver to instantiate Passthrough + PeekPokeTester and execute the test. // Don&#39;t worry about understanding this code; it is very complicated Scala. // Think of it more as boilerplate to run a Chisel test. val testResult = Driver(() =&gt; new Passthrough()) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) // Set our input to value 0 expect(c.io.out, 0) // Assert that the output correctly has 0 poke(c.io.in, 1) // Set our input to value 1 expect(c.io.out, 1) // Assert that the output correctly has 1 poke(c.io.in, 2) // Set our input to value 2 expect(c.io.out, 2) // Assert that the output correctly has 2 } } assert(testResult) // Scala Code: if testResult == false, will throw an error println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . What&#39;s going on? The test accepts a Passthrough module, assigns values to the module&#39;s inputs, and checks its outputs. To set an input, we call poke. To check an output, we call expect. If we don&#39;t want to compare the output to an expected value (no assertion), we can peek the output instead. . If all expect statements are true, then our boilerplate code will return true (see testResult). . **Exercise: Writing Your Own Testers** Write and execute two tests, one that tests PassthroughGenerator for a width of 10 and a second that tests PassthroughGenerator for a width of 20. Check at least two values for each: zero and the maximum value supported by the specified width. Note that the triple question mark has a special meaning in Scala. You may see it frequently in these bootcamp exercises. Running code with the ??? will produce the NotImplementedError. Replace ??? with your testers. . val test10result = ??? val test20result = ??? assert((test10result == true) &amp;&amp; (test20result == true)) println(&quot;SUCCESS!!&quot;) // Scala Code: if we get here, our tests passed! . Solution (click to toggle displaying it) val test10result = Driver(() =&gt; new PassthroughGenerator(10)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1023) expect(c.io.out, 1023) } } val test20result = Driver(() =&gt; new PassthroughGenerator(20)) { c =&gt; new PeekPokeTester(c) { poke(c.io.in, 0) expect(c.io.out, 0) poke(c.io.in, 1048575) expect(c.io.out, 1048575) } } . . Looking at Generated Verilog/FIRRTL . If you are having trouble understanding the generated hardware and are comfortable with reading structural Verilog and/or FIRRTL (Chisel&#39;s IR which is comparable to a synthesis-only subset of Verilog), then you can try looking at the generated Verilog to see the result of Chisel execution. . Here is an example of generating the Verilog (which you&#39;ve seen already) and the FIRRTL. . // Viewing the Verilog for debugging println(getVerilog(new Passthrough)) . // Viewing the firrtl for debugging println(getFirrtl(new Passthrough)) . . You&#39;re done! . Return to the top. . Appendix: A Note on &quot;printf&quot; Debugging . Debugging with print statements is not always the best way to debug, but is often an easy first step to see what&#39;s going on when something doesn&#39;t work the way you expect. Because Chisel generators are programs generating hardware, there are some extra subtleties about printing generator and circuit state. It is important to remember when your print statement executes and what is being printed. The three common scenarios where you might want to print have some important differences: . Chisel generator prints during circuit generation | Circuit prints during circuit simulation | Tester prints during testing | . println is a built-in Scala function that prints to the console. It cannot be used to print during circuit simulation because the generated circuit is FIRRTL or Verilog- not Scala. . The following code block shows different styles of printing. . class PrintingModule extends Module { val io = IO(new Bundle { val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) }) io.out := io.in printf(&quot;Print during simulation: Input is %d n&quot;, io.in) // chisel printf has its own string interpolator too printf(p&quot;Print during simulation: IO is $io n&quot;) println(s&quot;Print during generation: Input is ${io.in}&quot;) } class PrintingModuleTester(c: PrintingModule) extends PeekPokeTester(c) { poke(c.io.in, 3) step(5) // circuit will print println(s&quot;Print during testing: Input is ${peek(c.io.in)}&quot;) } chisel3.iotesters.Driver( () =&gt; new PrintingModule ) { c =&gt; new PrintingModuleTester(c) } .",
            "url": "https://coderbee.github.io/sculpt/2020/07/07/chisel-cookbook.html",
            "relUrl": "/2020/07/07/chisel-cookbook.html",
            "date": " • Jul 7, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://coderbee.github.io/sculpt/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://coderbee.github.io/sculpt/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . The toolchain used for hardware generation is Chisel 1. . a HCL (hardware construction language) &#8617; . |",
          "url": "https://coderbee.github.io/sculpt/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://coderbee.github.io/sculpt/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}